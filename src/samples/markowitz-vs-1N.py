# -*- coding: utf-8 -*-
"""Markowitz vs 1/N.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1exD8126QbVkXXDRUs7l2iiePtISw3axi
"""

# !pip install pyhomebroker --upgrade --no-cache-dir

from pyhomebroker import HomeBroker
import datetime
import pandas as pd
import requests
import scipy.optimize as sco
from scipy import stats
import numpy as np
import matplotlib.pyplot as plt
import scipy
import yfinance as yf

"""Voy a usar pyhomebroker + cocos para bajar la data. Me la trae mas limpia que yfinance =) """

codigo_broker = 265 # cocos capital
dni_cuenta = 32471866 # tu dni
user_cuenta = 'froux' # tu nombre de usuario
user_password = 'fgRoux32471866' # tu contraseña
comitente = 31559

## homebroker 265 es cocos capital
hb = HomeBroker(codigo_broker)

## log in: aca usar las credenciales propias
hb.auth.login(dni=dni_cuenta, user=user_cuenta, password=user_password, raise_exception=True)
hb.online.connect()

"""Codigo auxiliar para bajar data y para redondear precios:"""

def ticker_get_data(hb, asset, date_from, date_to):
    ''' Toma una lista de tickers y un objeto homebroker y 
        busca los precios desde date_from hasta date_to.
        Devuelve un dataframe con esa data. '''
    
    date_from = datetime.datetime.strptime(date_from,"%Y-%m-%d").date()
    date_to = datetime.datetime.strptime(date_to,"%Y-%m-%d").date()
    data = hb.history.get_daily_history(asset, date_from, date_to)
    
    data.loc[:,"date"] = pd.to_datetime(data.loc[:,"date"])
    data = data.set_index("date")
    return data


def get_dataset(hb, tickers, date_from, date_to):
    ''' Toma una lista de tickers y un objeto homebroker. Para cada asset llama
        a la funcion ticker_get_datas y se queda con el precio de cierre.
        Concatena todas las Series en un dataframe y lo devuelve. '''
    
    df = []
    for t in tickers:
        ticker_data = ticker_get_data(hb, t, date_from, date_to)
        ticker_data = ticker_data.close
        ticker_data.name = t
        df.append(ticker_data)
        
    return pd.concat(df,1)

def round_price(price):
    decimals = price % 1
    price_no_decimals = price//1 
    
    if (price > 250) and (decimals != 0.5):
        price = round(price)
        
    elif (price > 100) and (price <=250) and (decimals not in [0, .25, .5, .75]):
        if decimals <.25:
            price =  price_no_decimals
        elif decimals >.25 and decimals <.5:
            price = price_no_decimals + 0.25
        elif decimals >.5 and decimals <.75:
            price = price_no_decimals + 0.5
        else:
            price = price_no_decimals + 0.75
    
    return price

"""Código auxiliar para 1/N:"""

def select_tickers(data, top = 10):
    
    '''Logica para elegir los tickers. Ordeno por Mediana/Mad, tomo las primeras "top" acciones'''
    
    ratio = data.median()/data.mad()
    top_tickers = ratio.sort_values(ascending=False).iloc[:top]
    tickers = list(top_tickers.index)
    return tickers

def get_1overN_portfolio(data, capital, top=10):
    
    ''' Calculo el portfolio 1/n eligiendo los tickers con select_tickers'''
    
    data = data.dropna(1)
    tickers = select_tickers(data, top)
    data = data.loc[:,tickers]
    money_per_asset = capital/len(tickers)
    
    current_price = data.iloc[-1,:]
    current_price = current_price.apply(round_price)
    n_assets = money_per_asset//current_price
    
    return n_assets

"""Código para calcular el portfolio de Markowitz  (max sharpe ratio)"""

def get_neg_sr(weights, mu, covmat): 
    ''' Toma retornos, matriz de var/cov y pesos.
        Calcula -1 * sharpe ratio (pero sin la riskfree) para un portfolio. '''
    weights = np.array(weights)
    ret = np.sum(np.array(mu) * weights) 
    vol = np.sqrt(np.dot(weights.T,np.dot(np.array(covmat),weights)))
    vol += 1e-5
    sr = ret/vol
    ## lo devuelvo * -1 para minimizar
    return -sr
  

def check_sum(weights): 
    return np.sum(weights) - 1

def get_markowitz( mu, covmat):
    
    ''' Hago optimizacion para calcular markowitz'''

    cons = ({'type':'eq','fun':check_sum})
    bounds = ((0,1),)*len(mu) 
    init_guess = [1/len(mu)]*len(mu)
    opt_results = sco.minimize(get_neg_sr, init_guess, 
                               method='SLSQP', bounds=bounds, constraints=cons, args=(mu, covmat))
    return opt_results["x"]


def get_basicMarkowitz_portfolio(data, capital):
    
    ''' A partir de data para calcular y capital genero la cantidad de 
        papeles a comprar de cada asset utilizando markowitz. 
        Es una version basica de markowitz. '''
    
    data = data.dropna(1)
    retornos = data.pct_change().dropna(0)
    mu = retornos.mean()
    covmat = retornos.cov()
    weights = get_markowitz(mu, covmat)

    portfolio = pd.Series(weights, index=data.columns)
    money_per_asset = portfolio *capital
    current_price = data.iloc[-1,:]
    current_price = current_price.apply(round_price)
    n_assets = money_per_asset//current_price
    n_assets = n_assets[n_assets>0]

    return n_assets

"""Defino parametros para ejecucion:"""

n_assets = 10
capital = 50000
inicio_data = '2019-10-01'
inicio_backtest = '2020-01-01'
fin_backstest = '2021-09-01'

## cuantos dias uso para calcular mediana y mad para elegir tickers
dias_seleccion_ticker = 60 

## cada cuantas ruedas rebalanceo
n_dias_rebalanceo = 5

capital = 50000

tickers = [
     'ALUA', 'BBAR', 'BMA', 'BYMA',
     'CEPU', 'COME', 'CRES', 'CVH',
     'EDN', 'GGAL', 'HARG', 'LOMA',
     'MIRG', 'PAMP', 'SUPV', 'TECO2',
     'TGNO4', 'TGSU2', 'TRAN', 'TXAR',
     'VALO', 'YPFD']

data = get_dataset(hb, tickers, inicio_data, fin_backstest)
data = data.fillna(method = "ffill")

## voy a rebalancear cada n_dias_rebalanceo 
## en el ejemplo, 5 ruedas (mas o menos 1 vez por semana)
## a partir del 2020-01-01
dias_rebalanceo = data.iloc[data.index >= inicio_backtest].index
ix_dias_rebalanceo = list(range(0,len(dias_rebalanceo), n_dias_rebalanceo))
dias_rebalanceo = dias_rebalanceo[ix_dias_rebalanceo]

"""Defino funcion de backtesting: voy a tomar una serie de dias de rebalanceo y en cada dia, ademas, mido cuanto vale mi portfolio"""

def backtestear(f_portfolio, capital, data, dias_rebalanceo, dias_seleccion_ticker ):
    portfolio = []
    lista_capital = []

    for dia in dias_rebalanceo:
        data_para_calcular = data[data.index <= dia].iloc[-dias_seleccion_ticker:]
        #data_para_calcular.dropna(1)1
        ultimo_dia = data_para_calcular.iloc[-2]
        dia_hoy  = data_para_calcular.iloc[-1]

        ## si tengo portfolio, al cierre anterior vendo todo:
        if len(portfolio):    
            valor_portfolio = ultimo_dia[portfolio.index].dot(portfolio) 
            capital = valor_portfolio + capital
            lista_capital.append(capital)

        ## y compro:
        portfolio = f_portfolio(data_para_calcular, capital)    
        precio_portfolio = dia_hoy[portfolio.index].dot(portfolio)
        capital -= precio_portfolio
    
    
    return pd.Series(lista_capital,index=dias_rebalanceo[1:])

lista_capital_1on = backtestear(get_1overN_portfolio, capital, data, dias_rebalanceo, dias_seleccion_ticker)
lista_capital_markowitz = backtestear(get_basicMarkowitz_portfolio, capital, data, dias_rebalanceo, dias_seleccion_ticker)

merv = yf.download("^MERV",start=inicio_backtest, end=fin_backstest)
merv = merv.Close[dias_rebalanceo].iloc[1:]

plt.plot(lista_capital_1on, label="1 over N")
plt.plot(lista_capital_markowitz, label="Markowitz")
plt.plot(merv, label="Merval")
plt.legend()
plt.title("Backtest")
_ = plt.xticks(rotation="45")